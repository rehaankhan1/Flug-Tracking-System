<!DOCTYPE html>
<html lang="en">
<head>
    <title>Real-Time Flight Tracker with Weather Overlay</title>
    <meta property="og:description" content="Display flight tracking with real-time weather overlays." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src='https://api.mapbox.com/mapbox-gl-js/v3.4.0/mapbox-gl.js'></script>
    <link href='https://api.mapbox.com/mapbox-gl-js/v3.4.0/mapbox-gl.css' rel='stylesheet' />
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6.5.0/turf.min.js"></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<div id="map"></div>

<script src="https://d3js.org/d3.v3.min.js" charset="utf-8"></script>
<script>
const openWeatherMapApiKey = '1df29cdb2c33d3a23fe6c74e8fcaaac8'; // Replace with your OpenWeatherMap API key

// Function to convert JSON to GeoJSON
function convertToGeoJSON(data) {
    const geoJSON = {
        type: "FeatureCollection",
        features: [{
            type: "Feature",
            geometry: {
                type: "LineString",
                coordinates: []
            },
            properties: {
                icao24: data.icao24,
                callsign: data.callsign
            }
        }]
    };
    data.path.forEach(point => {
        const [timestamp, latitude, longitude] = point;
        geoJSON.features[0].geometry.coordinates.push([longitude, latitude]);
    });
    return geoJSON;
}

// Function to add weather overlay based on conditions
async function addWeatherLayer(latitude, longitude) {
    const url = `https://api.openweathermap.org/data/2.5/weather?lat=${latitude}&lon=${longitude}&appid=${openWeatherMapApiKey}`;
    const response = await fetch(url);
    const weatherData = await response.json();
    const weatherCondition = weatherData.weather[0].main.toLowerCase();

    // Clear existing weather layers
    ['clouds-layer', 'precipitation-layer', 'wind-layer'].forEach(layerId => {
        if (map.getLayer(layerId)) map.removeLayer(layerId);
        if (map.getSource(layerId)) map.removeSource(layerId);
    });

    // Add weather layers based on conditions
    if (weatherCondition.includes("cloud")) {
        map.addSource('clouds-source', {
            type: 'raster',
            tiles: [
                `https://tile.openweathermap.org/map/clouds_new/{z}/{x}/{y}.png?appid=${openWeatherMapApiKey}`
            ],
            tileSize: 256
        });
        map.addLayer({
            id: 'clouds-layer',
            type: 'raster',
            source: 'clouds-source',
            paint: { 'raster-opacity': 0.5 }
        });
    }
    if (weatherCondition.includes("rain") || weatherCondition.includes("drizzle")) {
        map.addSource('precipitation-source', {
            type: 'raster',
            tiles: [
                `https://tile.openweathermap.org/map/precipitation_new/{z}/{x}/{y}.png?appid=${openWeatherMapApiKey}`
            ],
            tileSize: 256
        });
        map.addLayer({
            id: 'precipitation-layer',
            type: 'raster',
            source: 'precipitation-source',
            paint: { 'raster-opacity': 0.6 }
        });
    }
    map.addSource('wind-source', {
        type: 'raster',
        tiles: [
            `https://tile.openweathermap.org/map/wind_new/{z}/{x}/{y}.png?appid=${openWeatherMapApiKey}`
        ],
        tileSize: 256
    });
    map.addLayer({
        id: 'wind-layer',
        type: 'raster',
        source: 'wind-source',
        paint: { 'raster-opacity': 0.4 }
    });
}

mapboxgl.accessToken = 'pk.eyJ1IjoibGV2ZWw5bmluZSIsImEiOiJjbHgxMGliczUwNzBkMmlxcHY5eGl3NXVuIn0.U42ZWqijRx_UDu-ciiBZmw';
const map = new mapboxgl.Map({
    container: 'map',
    style: 'mapbox://styles/level9nine/clxdqm3b8001j01pc3ekp0phz',
    projection: 'globe',
    bearing: 0,
    pitch: 10,
});

// Get 'icao24' parameter from URL
const icao24 = new URLSearchParams(window.location.search).get('icao24');

let firstLoad = true;

if (icao24) {
    map.on('load', () => {
        map.addControl(new mapboxgl.NavigationControl());

        function updateMapData() {
            d3.json(`/track?icao24=${icao24}`, async (err, data) => {
                if (err && err.status === 500) {
                    clearInterval(updateMapData);
                    new mapboxgl.Popup({ closeOnClick: false })
                        .setLngLat(map.getCenter())
                        .setHTML("<h3>Flight Landed</h3><p>No further data is available.</p>")
                        .addTo(map);
                    return;
                }

                if (err) throw err;

                data = convertToGeoJSON(data);
                const coordinates = data.features[0].geometry.coordinates;
                const endPoint = coordinates[coordinates.length - 1];
                const prevPoint = coordinates[coordinates.length - 2];

                const lat1 = prevPoint[1] * (Math.PI / 180);
                const lon1 = prevPoint[0] * (Math.PI / 180);
                const lat2 = endPoint[1] * (Math.PI / 180);
                const lon2 = endPoint[0] * (Math.PI / 180);
                const dLon = lon2 - lon1;
                const x = Math.sin(dLon) * Math.cos(lat2);
                const y = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);
                let bearing = Math.atan2(x, y);
                bearing = (bearing * (180 / Math.PI) + 360) % 360;

                if (map.getSource('trace')) {
                    map.getSource('trace').setData(data);
                } else {
                    map.addSource('trace', { type: 'geojson', data });
                    map.addLayer({
                        'id': 'trace',
                        'type': 'line',
                        'source': 'trace',
                        'paint': {
                            'line-color': 'red',
                            'line-opacity': 1,
                            'line-width': 5
                        }
                    });
                }

                const pointGeoJSON = {
                    type: 'FeatureCollection',
                    features: [{
                        type: 'Feature',
                        geometry: { type: 'Point', coordinates: endPoint },
                        properties: { bearing: bearing }
                    }]
                };

                if (map.getSource('point1')) {
                    map.getSource('point1').setData(pointGeoJSON);
                    map.setLayoutProperty('point1', 'icon-rotate', bearing);
                } else {
                    map.addSource('point1', { type: 'geojson', data: pointGeoJSON });
                    map.addLayer({
                        'id': 'point1',
                        'source': 'point1',
                        'type': 'symbol',
                        'layout': {
                            'icon-image': 'airport-9',
                            'icon-size': 2.2,
                            'icon-rotation-alignment': 'map',
                            'icon-allow-overlap': true,
                            'icon-ignore-placement': true,
                            'icon-rotate': bearing
                        }
                    });
                }

                if (firstLoad) {
                    map.flyTo({
                        center: endPoint,
                        zoom: 7,
                        pitch: 40,
                        speed: 1.2,
                        curve: 1.42
                    });
                    firstLoad = false;

                    // Add weather layer on first load at the endpoint
                    await addWeatherLayer(endPoint[1], endPoint[0]);
                }
            });
        }

        updateMapData();
        setInterval(updateMapData, 5000);
    });
} else {
    alert('Error: The "icao24" parameter is required in the URL.');
}
</script>
</body>
</html>
